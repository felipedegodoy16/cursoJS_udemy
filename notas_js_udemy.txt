VARIÁVEIS

- var -> não é bom utilizar mais var, é uma declaração antiga, não é bom utilizar por conta de seu escopo ser global, ou seja, ser vista até mesmo no dom do projeto não somente dentro das funções ou blocos de código igual ocorre com o let, pode ser redeclarada que não irá gerar um erro, tem escopo de função, ou seja, se for declarado dentro da função fora dela não é possível visualizar a variável

- let -> mais utilizada atualmente, seu escopo é local até mesmo para blocos de código como estruturas de repetição e estruturas de condição, usar sempre LET e não VAR, se redeclarar a variável com o let ela irá gerar um erro falando que a variável já foi declarada, tem escopo de bloco, ou seja, se declarado dentro de um bloco de código não poderá ser utilizado fora dele, por exemplo dentro de uma estrutura IF, assim como pode ser declarada uma variável let com o mesmo nome dentro do if e fora dele que não irá gerar um erro

- const -> segue a mesma ideia do let, porém, a constante não aceita uma reatribuição de valores, ou seja, ela aceita apenas que você coloque nela um valor inicial e até o fim da aplicação ela continua tendo o mesmo valor, se a const for um array ou objeto é possível alterar seu valor, ou seja, é impossível pra uma const ser reatribuído um valor, porém, é possível alterar um valor de um array para o qual uma constante esteja apontando, o mesmo vale para objetos

- no JS é possível atribuir um valor a uma variável direto sem declarar ela, por padrão ela será criada como uma VAR
- não é possível criar variáveis com palavras reservadas -> let, const, console...
- criar variáveis sempre com nome explicativos do para que essa variável serve -> uma variável para guardar o salário de alguém declare essa variável com o nome 'salario'
- é melhor sempre iniciar as variáveis com letras minúsculas, não utilizar espaço dentro das variáveis se for usar duas palavras diferentes utilizar camelCase, o JS é case sensitive, ou seja, nome != Nome

----------------------------------------------------------------------------------------------------------

TIPOS DE DADOS

- string -> é o tipo de dado que fica entre aspas simples, aspas duplas e crazes (no caso das crazes é possível usar os template strings), é um tipo de dado indexado, ou seja, cada caractere dentro de uma string é entendido como tendo um índice, ou seja, é possível acessar cada caractere da string através de seu índice

- number -> podendo ele ser de ponto flutuante (com vírgula) ou inteiro

- undefined -> quando não há nenhum valor atribuído a essa variável, ou seja, não aponta para lugar nenhum

- null -> mesmo que o undefined, porém, esse serve para objetos e é usado para atribuir valor nulo a uma variável, EX: se um usuário pode escolher uma cor para algo dentro do sistema e ele não escolhe cor nenhuma você atribui nulo para a variável que armazena a cor

- booleano -> true ou false (valor lógico)

- array -> armazena vários valores dentro dele

- object -> é um objeto que pode conter atributos e métodos

- function -> é um bloco de código que resolve um pequeno problema e pode ser chamado várias vezes durante a execução, reproveitamento de código 

- Primitivos (imutáveis) -> string, number, boolean, undefined, null (bigint, symbol) -> todos esses quando passado para uma variável é COPIADO o valor, ou seja, se tenho uma variável com esse tipo de dado e passo a outra variável é feito uma cópia do valor, ou seja, as variáveis são independentes, se alterar uma não irá alterar a outra 
- Não Primitivos (mutáveis) -> array, object, function -> são passados por referência, ou seja, se uma variável contiver o valor de um array e eu passar essa variável a outra elas se tornam dependentes, ou seja, se alterar o valor de alguma delas as duas serão alteradas 

----------------------------------------------------------------------------------------------------------

OPERADORES ARITMÉTICOS

- adição (+) -> somar números, podendo ser utilizado também para concatenação de strings 

- subtração (-) -> subtrair números 

- multiplicação (*) -> multiplicar números 

- divisão (/) -> dividir números 

- potenciação (**) -> potência do número

- resto (%) -> retorna o resto da divisão 

- incremento (++) -> soma +1 ao valor da variável -> tem o pré e o pós, o pré primeiro ele soma depois ele executa a ação, o pós primeiro ele executa a ação e depois ele soma

- decremento (--) -> subtrai -1 ao valor da variável -> tem o pré e o pós, o pré primeiro ele subtrai depois ele executa a ação, o pós primeiro ele executa a ação e depois ele subtrai

----------------------------------------------------------------------------------------------------------

OPERADORES DE ATRIBUIÇÃO

- atribuição normal (=) -> atribui um valor a uma variável 

- atribuição com adição (+=) -> pode colocar um valor que quiser que vai fazer o valor da variável + o valor desejado

- atribuição com subtração (-=) -> pode colocar um valor que quiser que vai fazer o valor da variável - o valor desejado

- atribuição com multiplicação (*=) -> pode colocar um valor que quiser que vai fazer o valor da variável * o valor desejado

- atribuição com divisão (/=) -> pode colocar um valor que quiser que vai fazer o valor da variável / o valor desejado

- atribuição com soma (**=) -> pode colocar um valor que quiser que vai fazer o valor da variável elevado ao valor desejado

- atribuição com soma (%=) -> pode colocar um valor que quiser que vai fazer o resto da divisão entre o valor da variável e o valor desejado

----------------------------------------------------------------------------------------------------------

FUNÇÕES 

Maneiras de Declaração e Chamada

// Função Normal 
function soma() {
    /* código */
}
soma();

// Função Anônima
const raiz = function () {
    /* código */
};
raiz();

// Arrow Function -> não muda o comportamento do 'this' -> MUITO IMPORTANTE
const raiz = () => {
    /* código */
};
raiz();

const raiz = n => n ** 0.5; // Maneira mais curta de declaração de uma arrow function

- uma coisa interessante que tem apenas para as functions expressions, ou seja, não funciona para as arrow functions é o objeto 'arguments', ou seja, uma função pode estar recebendo inúmeros argumentos porém, não estar diretamente recebendo eles, esses valores acabam ficando armazenados em um objeto chamado arguments, onde cada índice desse objeto conterá um valor que foi passado como argumento para a função 

function funcao() {
    arguments // esse objeto armazena todos os valores que foram passados para a função
}
funcao('valor', 1, 2, 3, 4);

- no JS se houver mais argumentos que parâmetros ele irá armazenar o número de argumentos que for o número de variáveis, se ocorrer o contrário, os parâmetros que não receberam nenhum valor serão inicializados ccom undefined

- a função pode receber parâmetros para serem usados dentro da mesma, é possível passar quantos argumentos quiser

- é possível passar argumentos para uma função assim como é possível estabelecer valores padrões para os argumentos, e para que esses valores padrões sejam colocados em vigor há duas maneiras de se fazer, ou não passar nenhum argumento ou onde eu quero que ele tenha o valor padrão da função eu passe 'undefined'

- é possível também fazer atribuição por desestruturação nos argumentos de uma função 

function funcao({ nome, sobrenome, idade }) {
    // código;
}
funcao({ nome: 'Luiz', sobrenome: 'Otávio', idade: 30 });

- é possível também usar o rest operator para pegar o resto dos valores, ele deve ser o último parâmetro a ser passado para a função, geralmente não é usado o objeto arguments, é mais comum se ver as pessoas utilizando o rest operator com 'args', '...args'

function conta(operador, acumulador, ...numeros) {
    // operador = '+';
    // acumulador = 0;
    // numeros = [10, 20, 30, 40];
}
conta('+', 0, 10, 20, 30, 40);

- é possível retornar funções dentro de outras funções, é bem usado para não repetir código e deixar seu código mais limpo e assertivo

function criaMultiplicador(multiplicador) {
    return function(n) {
        return n * multiplicador;
    };
}

const duplica = criaMultiplicador(2);
const triplica = criaMultiplicador(3);
const quadriplica = criaMultiplicador(4);

console.log(duplica(2)); // 4
console.log(triplica(2)); // 6
console.log(quadriplica(2)); // 8

- CLOSURE -> habilidade que uma função tem de acessar seu escopo léxico

- CALLBACK -> são basicamente coisas que quero chamar depois que alguma ação for finalizada 

- IIFE (Immediately Invoked Function Expression) FUNÇÕES IMEDIATAS -> basicamente essa função ao mesmo tempo que ela é criada ela já é invocada imediatamente
(function() {
    // código;
})();
// assim se cria uma função e imediatamente já a invoca para ser usada, geralmente utilizada para fugir do escopo global de uma aplicação, a ideia é que ela envolva todo o código JS da sua aplicação porém já o invocando imediatamente 

- FACTORY FUNCTIONS (FUNÇÕES FÁBRICA) -> são as funções que criam objetos e retornam eles

- CONSTRUCTOR FUNCTIONS (FUNÇÕES CONSTRUTORAS) -> é muito parecido com o cosntructor das classes, sua primeira letra é maiúscula e para instanciar um objeto é preciso utilizar a palavra 'new', é possível criar atributos privados e públicos, sendo os privados declarados com 'let' ou 'const' enquanto os públicos são declarados apenas com a palavra 'this'
function Pessoa(nome, sobrenome) {
    const ID = 123456;
    const metodoInterno = () => {
        // código do método;
    };
    this.nome = nome;
    this.sobrenome = sobrenome;
    this.metodo = () => {
        // código desse método;
    };
}
const p1 = new Pessoa('Luiz', 'Otávio');

- FUNÇÕES RECURSIVAS -> basicamente é chamar sua função dentro dela mesma, tomar cuidado pois os motores do JS ou do navegador podem interpretar como um erro se ela ficar recursivando para sempre, e também para conseguir sair da recursividade da sua função 

- FUNÇÕES GERADORAS -> é uma função que é possível fazer ela retornar um valor e depois continuá-la do mesmo ponto que ela havia parado, se utilizar o return dentro dela ai ela irá acabar no return, não será possível chamar seu próximo 'yield'
function* geradora1() {
    yield 'valor1';
    yield 'valor2';
} 
const g1 = geradora1();
console.log(g1.next().value); // valor1
console.log(g1.next().value); // valor2

- sempre que for passar uma função como argumento de outra função ou algo do tipo, precisa ser passada por referência, ou seja, precisa passar a função sem os parênteses

- parseInt() -> converter um tipo de dado em um número inteiro, se tentar converter um número decimal ele irá retornar apenas o valor inteiro do número e irá ignorar o que vem após o ponto

- parseFloat() -> converter um tipo de dado em um número de ponto flutuante

- Number() -> melhor de se usar, pois, irá retornar um número inteiro se for inteiro e se for decimal ele retorna decimal, ele se vira para saber se é inteiro ou não

- alert() -> função para chamar um popup com a mensagem que você passar dentro dos parênteses

- confirm() -> função que cria um popup de confirmação, onde aparecem dois botões para o usuário, caso clique em 'ok' é retornado um valor booleano true e caso seja clicado 'cancelar' o valor booleano retornado é false, dentro dos parênteses também é passado uma string com uma mensagem para o usuário

- prompt() -> função que chama um popup onde o usuário pode digitar algo, é retornado o que o usuário digitar dentro desse prompt, dentro dos parênteses é passado a mensagem que quer que mostre ao usuário

- charAt() -> usada para retornar o caractere de uma string na posição que for passada dentro dos parênteses, EX: string.charAt(5) -> retorna o caractere que está na posição 5 na variável 'string'

- concar() -> usada para concatenar um texto, muito pouco usado, mais fácil utilizar o operador + ou dependendo utilizar template string

- indexOf() -> usado para retornar o índice de algo, no caso, de algum caractere, é possível passar mais de um parâmetro, usado às vezes para começar de um certo índice que quiser, ele irá retornar o primeiro índice que encontrar

- lastIndexOf() -> mesma coisa que o indexOf() -> porém, retorna o último índice que encontrar

- match() -> usado para retornar caso de match com alguma coisa dentro da string, EX: texto.match('o') -> irá retornar a letra 'o', que é o que deu match com a expressão que coloquei dentro dos parênteses, geralmente usado com expressões regulares (regex)

- search() -> retorna o índice do que você pesquisou, bem parecido com o indexOf

- replace() -> faz um replace de algo dentro da string, EX: texto.replace('t', 'm') -> 'mexmo'

- slice() -> passado dois números como parâmetro, fará um recorte da string começando do primeiro número que for passado por parâmetro e terminando no último, importante saber que sempre tem que colocar 1 índice a mais do que a letra de onde você quer, o último índice que você passa não é contabilizado no slice, se for passado apenas um parâmetro, ele irá começar daquele número e ir até o final da string 

- substring() -> parecido com o slice mas um pouco mais complexo, melhor usar o slice mesmo

- split() -> usado para dividir uma string em um array que seja separado através de algo que você passe, EX: string.split(' ') -> irá separar um índice para cada palavra que for espaçada por um espaço 

- splice() -> faz tudo o que as funções pop, push, shift e unshift fazem e mais um pouco ainda, dentro dos parênteses pode ser passado (indice, delete, elem1, elem2, elem3...), basucamente passa o índice em que será iniciado, quantos elementos serãok removidos a partir daquele indice, e os elementos para serem inseridos, retorna um array com os elementos que foram removidos, se quiser remover todos os elementos após aquele índice que foi passado basta usar 'Number.MAX_VALUE'

- toUpperCase() -> converter toda a string em upper case

- toLowerCase() -> converter toda a string em lower case 

- toString() -> converter algo em string, há algunas parâmetros que podem ser passados dentro dos parênteses, por exemplo, se for passado '2' ele converte o número por exemplo para um número binário

- toFixed() -> para limitar o número de casas decimais de um número, dentro dos parênteses é passado o número de casas que quero que ele limite, o número é arredondado

- Number.isInteger() -> é uma função que retornar true ou false para verificar se o número é inteiro ou não

- Number.isNaN() -> segue a mesma ideia do isInteger, vai retornar true se o número for um NaN 

- array.push() -> usado para adicionar um elemento ao final do array

- array.unshift() -> usado para adicionar um elemento no início do array, consequentemente os elementos que vem depois irão mudar de índice

- array.pop() -> remove o último elemento do array, interessante saber que ele retorna o elemento que está sendo removido, ou seja, se quiser salvar esse elemento em uma variável é possível 

- array.shift() -> remove o primeiro elemento do array, assim como o pop ele também retorna o elemento que está sendo removido

- document.createElement() -> cria um elemento HTML no JS, ou seja, para criar um novo elemento basta fazer dessa forma, dentro dos parênteses é passado o elemento que quer que seja criado 

- element.appendChild() -> usado para inserir um elemento em outro, ou seja, nesse caso, 'element' seria um elemento qualquer, podendo ser uma div, section ou qualquer outro e o appendChild irá inserir um novo elemento dentro desse elemento, o que quer que seja inserido é passadoa dentro dos parênteses

- classList() -> usado para fazer uma listagem das classes de um elemento, geralmente é utilizado para ver se há uma certa classe dentro do elemento(contains()) e adicionar(add()) ou remover (remove()) uma classe

- getComputedStyle() -> pegar os estilos CSS de um elemento que eu passar como parâmetro dessa função 

- setInterval() -> é uma função que seta um intervalo de tempo para fazer alguma coisa, geralmente é passado como parâmetro outra função por referência, ou seja, essa função é passada sem os parênteses, que significa que ela não está sendo chamada para ser executada e passado o tempo também em milissegundos, geralmente é criada uma função anônima como parâmetro para não ficar criando funções para isso, essa função executará para sempre se ela não tiver algo para pará-la, geralmente é colocada dentro de uma variável para que possa ser parada em algum momento

- clearInterval() -> usada para parar a função setInterval(), é passado o nome do setInterval como parâmetro para que ela saiba qual função parar 

- setTimeout() -> parecido com o setInterval(), porém, ele executa apenas uma vez

EX:
const timer = setInterval(function() {
    console.log('teste');
}, 1000);

setTimeout(function() {
    clearInterval(timer);
}, 10000);

// esse exemplo irá executar o timer durante 10 segundos que é quando será chamado o setTimeout e fará o setInterval parar 

- remove() -> usado para remover, pode ser um elemento, uma classe, etc 

- trim() -> remove os espaços que tiverem em uma string

- bind() -> essa função geralmente é usada junto de uma função para bindar oputro valor pra algo, geralmente para mudar o comportamento do 'this'

- concat() -> usado para concatenação

- endsWith() -> usado para verificar se uma string termina com algum caractere específico 

//////////////////////////////////////////////////////////////////////////////////////////////////////////

FILTER

- sempre retorna um array com a mesma quantidade de elementos ou menos elementos do que esse array
- é uma função para Arrays, geralmente é passada uma função de callback para o filter com uma condição para retornar os valores
- na função de callback é possível receber um valor de cada vez, o índice desse valor e o array como um todo 

const numeros = [5, 50, 80, 1, 2, 3, 5, 8, 7, 11, 15, 22, 27];
const numerosFiltrados = numeros.filter((valor, indice, array) => {
    console.log(valor, indice, array);
    return valor > 10;
});

//////////////////////////////////////////////////////////////////////////////////////////////////////////

MAP

- sempre retorna um array com a mesma quantidade de elementos do array que iniciou
- é uma função para Arrays, geralmente é passada uma função de callback para o map com uma condição que irá alterar e manipular os elementos
- na função de callback é possível receber um valor de cada vez, o índice desse valor e o array como um todo 

const numeros = [5, 50, 80, 1, 2, 3, 5, 8, 7, 11, 15, 22, 27];
const dobro = numeros.map((valor, indice, array) => {
    console.log(valor, indice, array);
    return valor * 2;
});

//////////////////////////////////////////////////////////////////////////////////////////////////////////

REDUCE

- essa função é utilizada para reduzir um array, é possível por exemplo retornar um array por exemplo, mas geralmente não é utilizado, é utilizado para reduzir um array para um único valor
- é uma função para Arrays, geralmente é passada uma função de callback para o reduce com uma condição que irá manipular os dados e retornar 1 único valor
- na função de callback é possível receber um acumulador, um valor de cada vez, o índice desse valor e o array como um todo 

const numeros = [5, 50, 80, 1, 2, 3, 5, 8, 7, 11, 15, 22, 27];
const total = numeros.reduce((acumulador, valor, indice, array) => {
    console.log(acumulador, valor, indice, array);
    acumulador += valor;
    return acumulador;
}, 0); // esse 0 é o valor inicial do acumulador

const pessoas = [
    { nome: 'Luiz', idade: 62 },
    { nome: 'Maria', idade: 23 },
    { nome: 'Eduardo', idade: 10 },
    { nome: 'Letícia', idade: 15 },
    { nome: 'Rosana', idade: 64 },
    { nome: 'Wallace', idade: 63 },
];
const maisVelha = numeros.reduce((acumulador, valor) => {
    if(acumulador.idade > valor.idade) return acumulador;
    return valor;
});
console.log(maisVelha); // irá mostrar a Rosana com idade 64, ela é a mais velha, toda vez que é retornado um valor no reduce esse valor passa a ser o acumulador

//////////////////////////////////////////////////////////////////////////////////////////////////////////

FOREACH

- uma função que é utilizada para iterar sobre um array
- é uma função para Arrays, geralmente é passada uma função de callback para o foreach com uma condição que irá manipular os dados
- na função de callback é possível receber um valor de cada vez, o índice desse valor e o array como um todo 

const numeros = [5, 50, 80, 1, 2, 3, 5, 8, 7, 11, 15, 22, 27];
let total = 0;
const total = numeros.forEach(valor => {
    total += valor;
});
console.log(total);

----------------------------------------------------------------------------------------------------------

ATRIBUTOS

- typeof -> retorna o tipo de algum dado que você queira consultar

- instanceof -> retorna true se a comparação que você estiver fazendo for verdadeira, ou seja, se você perguntar se uma variável é uma instância de uma classe e isso for verdadeiro ele retorna true, se não, retorna false

- length -> retorna o número de caracteres de uma string por exemplo

- innerHTML -> inserir texto HTML dentro de um elemento, EX: documnet.body.innerHTML = '<p>Testando a tag</p>'

----------------------------------------------------------------------------------------------------------

ARRAYS

- push() -> para adicionar um elemento ao final do array

- unshift() -> para adicionar um elemento ao início do array, os elementos que já existem no array vão mudar de índice, serão empurrados para frente 

- pop() -> remove o último elemento do array, interessante saber que ele retorna o elemento que está sendo removido, ou seja, se quiser salvar esse elemento em uma variável é possível 

- shift() -> remove o primeiro elemento do array, assim como o pop ele também retorna o elemento que está sendo removido

- slice() -> funciona da mesma forma que funciona com as strings

- delete -> esse atributo deleta um elemento de um índice sem mexer nos índices de outros elementos, onde foi removido o elemento fica um espaço vazio

- length -> retorna o tamanho do array 

- para copiar o valor de um array para outra variável sem que isso seja passado por referência basta utilizar [...array], EX: let b = [...a];

- sempre seus elementos estarão dentro de colchetes e serão separados por vírgula 

- o JS não restringe os tipos de dados que estarão dentro de um array, ou seja, você pode ter dentro de um mesmo array strings, numeros, booleanos, etc, mas não é uma boa prática isso, sendo assim, sempre será melhor criar arrays com os mesmos tipos de dados dentro desse array, isso é uma boa prática de programação 

- concat() -> usado para fazer uma concatenação, geralmente também é usado o spread operator

----------------------------------------------------------------------------------------------------------

OBJETOS

function criaPessoa(nome, sobrenome, idade) {
    return { nome, sobrenome, idade }; // quando o atributo e o valor tem o mesmo nome não é necessário colocar 'chave: valor', pode colocar daquela forma que está representada
}

- dentro do objeto é possível criar métodos para ele sem usar a palavra 'function' antes, é possível deixar apenas o nome do método 
EXEMPLO:
const pessoa1 = {
    nome: 'Luiz',
    sobrenome: 'Miranda',
    idade: 25,

    fala() {
        console.log(`${this.nome} ${this.sobrenome} está falando oi...`);
    }
};

- quando quero chamar algo dentro do próprio objeto é possível usar a palavra reservada 'this', que referencia o próprio objeto, o 'this' referencia quem chamou a função, ou seja, nem sempre por estar dentro de um objeto esse this vai estar referenciando o próprio objeto, as vezes ele pode por exemplo estar referenciando o document dependendo de como for utilizado 

- para copiar o valor de um objeto para outra variável sem que isso seja passado por referência basta utilizar {...object}, EX: let b = {...a};

- para chamar alguma chave de um objeto basta utilizar objeto.chave ou objeto['chave']

- se um método dentro do objeto tiver a palavra 'get' antes de sua declaração ele passa a ser um atributo do objeto e não mais um método apenas, ou seja, para chamar esse método basta apenas chamar seu nome, não precisando chamar seu nome com os ()

- se um método dentro do objeto tiver a palavra 'set' antes de sua declaração ele se torna um método setter igual a orientação a objetos 

- defineProperty - define uma propriedade do objeto, pode mexer na propriedade também 
function Produto(nome, preco, estoque) {
    this.nome = nome;
    this.preco = preco;

    Object.defineProperty(this, 'estoque', { // está mexendo nesse objeto, na propriedade estoque
        enumerable: true, // define a propriedade no objeto
        value: estoque, // define o valor da propriedade
        writable: false, // permite alterar o valor ou não
        configurable: true // é configurável ou não, ou seja, essa propriedade pode ser reconfigurada ou deletada
    });
}

- defineProperties - define várias propriedades de um objeto ao mesmo tempo
Object.defineProperties(this, {
    nome: {
        enumerable: true, // define a propriedade no objeto
        value: nome, // define o valor da propriedade
        writable: false, // permite alterar o valor ou não
        configurable: true // é configurável ou não, ou seja, essa propriedade pode ser reconfigurada ou deletada
    },
    preco: {
        enumerable: false, // define a propriedade no objeto
        value: preco, // define o valor da propriedade
        writable: true, // permite alterar o valor ou não
        configurable: true // é configurável ou não, ou seja, essa propriedade pode ser reconfigurada ou deletada
    }
});

- Funções de Objetos no JS

-- Copiar um objeto para outro
--- é possível utilizar o spread operator ou usar Object.assign({}, objeto, { propriedade: 'valor' });
--- o spread operator é mais intuitivo, geralmente é mais utilizado

-- Object.keys(objeto) -> mostra as chaves que esse objeto possui 

-- Object.freeze(objeto) -> para congelar um objeto, torna o objeto algo que não pode ser alterado

-- Object.getOwnPropertyDescriptor(obj, 'prop') -> retorna as propriedades daquela chave, como está seu writable, enumerable, configurable...

-- Object.values(objeto) -> mostra os valores que esse objeto possui sem suas chaves

-- Object.entries(objeto) -> retorna um array de chave e valor para cada uma das chaves que existem

- Prototypes -> são propriedades de um objeto que são criadas pelo pai do objeto e herdadas pelo filho, ou seja, não são instanciadas sempre, são instanciadas apenas quando precisam
Pessoa.prototype.estouAqui = 'Hahaha'; // cria-se uma propriedade estouAqui dentro da propriedade prototype

- Object.setPrototypeOf(objB, objA); // isso vai alterar para que o __proto__ de objB seja o objA
- Object.getPrototypeOf(objA); // utilizado para acessar o prototype de um objeto, maneira certa de se acessar

- const produto = Object.create(Produto.prototype); // cria um objeto produto e define sua prototype como a prototype da função construtora Produto

- "Herança" em JS, seria mais uma delegação onde é possível passar protótipos de um objeto para outro, assim, se alguma propriedade não existir no primeiro protótipo ele busca no segundo e assim por diante até o topo da cadeia de protótipos
function Produto(nome, preco) {
    this.nome = nome;
    this.preco = preco;
}

function Caneca(nome, preco, material){
    Produto.call(this, nome, preco);
}

Caneca.prototype = Object.create(Produto.prototype);
Caneca.prototype.constructor = Caneca;

// há duas "classes" sendo elas Produto e Caneca, assim caneca herda Produto, a função call é usada para se chamar a outra função construtora

- Polimorfismo em JS
-- É basicamente quando duas classes filhas ou duas funções construtoras filhas herdam um método da classe pai e sobrescrevem esse método para seus próprios interesses, ou seja, o mesmo método é diferente para as duas classes filhas mesmo herdando esse método da classe pai

- Classe em JS
-- É declarada apenas colocando 'class Nome {}'
-- os métodos get e set não são usados apenas para os atributos da classe, podem ser usados como uma simples função com algum outro nome sem ser o nome dos atributos, porém para chamá-los utiliza-se como se fossem atributos 

- Métodos estáticos
-- sempre que eu não utilizar a palavra 'this' dentro de um método posso transformá-lo em um método estático
-- usado para fazer algo em todos os objetos de uma classe, é chamado através do nome da própria classe 
class ControleRemoto {
    constructor(tv) {
        this.tv = tv;
        this.volume = 0;
    }

    aumentarVolume() {
        this.volume += 2;
    }

    diminuirVolume() {
        this.volume -= 2;
    }

    static trocaPilha() {
        console.log('Ok, vou trocar.');
    }
}

const controle1 = new ControleRemoto('Samsung');

ControleRemoto.trocaPilha();

----------------------------------------------------------------------------------------------------------

PROMISES
- usadas para substituir as funções de callback, basicamente são utilizadas para que uma função ocorra obrigatoriamente em sequência de outra

- o que vem abaixo das promises será executado antes mesmo das promises, as promises rodam em paralelo ao seu código, ou seja, o JS executa as promises enquanto executa outros códigos também

function rand(min, max) {
    min *= 1000;
    max *= 1000;
    return Math.floor(Math.random() * (max - min) + min);
}

function esperaAi(msg, tempo) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(msg);
        }, tempo);
    });
}

esperaAi('Frase 1', rand(1, 3))
    .then(resposta => { // esse parâmetro 'resposta' é a msg que passamos no 'resolve'
        console.log(resposta);
        return esperaAi('Frase 2', rand(1, 3));
    })
    .then(resposta => {
        console.log(resposta);
    })
    .catch();

-- then -> usada para quando se der certo a 'promise', no caso quando quisermos usar o 'resolve' passado como 'parâmetro' da promise, se for retornado algo é preciso colocar outro 'then' encadeado no primeiro, o 'then' recebe como parâmetro o que é passado como argumento para o 'resolve'

-- catch -> usada para quando ocorrer algum erro e quisermos tratar esse erro, vai ser útil quando quisermos usar o 'reject' passado como parâmetro da 'promise', o 'catch' recebe como parâmetro o que estamos passando de argumento para o 'reject', caso ocorra um 'reject' ele não executa os outros 'resolve', ele para a execução do código da 'promise', o que está fora da promise continua rodando mesmo assim

----------------------------------------------------------------------------------------------------------

OBJETOS DO JS

- Math -> é um objeto que tem alguns métodos matemáticos prontos que você pode utilizar
-- Math.ceil() -> é passado dentro dos parênteses o que você quer arredondar para cima
-- Math.floor() -> é passado dentro dos parênteses o que você quer arredondar para baixo
-- Math.round() -> é passado dentro dos parênteses o que você quer arredondar, ele automaticamente arredondará para cima ou para baixo dependendo do número, vai arredondar para o mais próximo
-- Math.max() -> é passado por parâmetro uma sequência de números e ele retorna o maior número que foi passado
-- Math.min() -> é passado por parâmetro uma sequência de números e ele retorna o menor número que foi passado
-- Math.random() -> gera um número aleatório entre 0 e 1 (1 não é incluído, ou seja, nunca irá gerar o número 1), nesse caso irá gerar um número decimal (Math.random() * (max - min) + min) // isso gera números aleatórios entre o máximo e o mínimo estipulado por você, é bom fazer isso em uma função e quando for retornar o valor colocar Math.floor(num), pois, sempre é gerado um número decimal com o random
-- Math.PI -> é o valor de pi caso queira utilizar em algum cálculo
-- Math.pow() -> passado por parâmetro a base e o expoente, usado para potenciação, pouco utilizado pois tem o operador ** que faz a mesma coisa 
-- Math.sqrt() -> usado para fazer a conta de raiz quadrada, porém, uma forma fácil de se fazer isso é utilizando o operador de potência, numero ** (1/2) -> isso também retorna a raiz quadrada de um número 

- Date -> é um objeto específico para manipulação de Data, sempre que for utilizá-la primeiro precisa instanciar um objeto dela, ou seja, 'const data = new Date();'
-- no objeto Date a data está em milésimos de segundos
-- é passado por parâmetro da classe os milissegundos caso seja um parâmetro apenas, caso sejam mais ele será identificado o primeiro como o ano, o segundo como mês, o terceiro como o dia, o quarto como as horas, o quinto como os minutos, o sexto como os segundos e o último como os milissegundos, os meses nessa classe começam do 0 e vão até o 11, não é do 1 - 12, se não for passado nenhum valor por parâmetro ele pega a data do sistema
-- é possível também passar a data como uma string que seja interpretada pelo JS, se for num formato que ele entende ele irá converter essa string em uma data válida
-- data.getDate() -> retorna o dia do mês que foi passado para a data
-- data.getMonth -> retorna o mês que foi passado para a data, esse mês é no formato do JS ou seja, de 0-11
-- data.getFullYear -> retorna o ano que foi passado para a data 
-- data.getHours() -> retorna a hora que foi passada para a data 
-- data.getMinutes() -> retorna os minutos que foram passados para a data 
-- data.getSeconds() -> retorna os segundos que foram passados para a data
-- data.getMilliseconds() -> retorna os milissegundos que foram passados para a data 
-- data.getDay() -> retorna o dia da semana que está, esse valor é de 0 (Domingo) até 6 (Sábado)
-- Date.now() -> retorna os milésimos de segundos da data atual 
-- data.toLocaleTimeString ou data.toLocaleString -> é passado por parâmetro para essas funções o local e um objeto
data.toLocaleString('pt-BR', {
    hour: '2-digit', // coloca dois dígitos na hora
    minute: '2-digit', // coloca dois dígitos nos minutos
    second: '2-digit', // coloca dois dígitos nos segundos
    hour12: false // torna o horário de 12 horas falso, ou seja, fica no padrão brasileiro de 24 horas 
})

----------------------------------------------------------------------------------------------------------

OPERADORES DE COMPARAÇÃO

- > -> maior que
- >= -> maior que ou igual a 
- < -> menor que
- <= -> menor que ou igual a 
- == -> igual a (valor)
- === -> igual a (valor e tipo)
- != -> diferente de (valor)
- !== -> diferente de (valor e tipo)

----------------------------------------------------------------------------------------------------------

OPERADORES LÓGICOS 

- && -> AND -> E -> todas as expressões precisam ser verdadeiras para retornar verdadeiro 
- || -> OR -> OU -> pelo menos uma expressão precisa ser verdadeira para retornar verdadeiro 
- ! -> NOT -> NÃO -> inverte o valor da expressão, ou seja, se retornar true ele irá inverter para false 

----------------------------------------------------------------------------------------------------------

OPERADOR TERNÁRIO

- o operador ternário é um IF e ELSE encurtado, a ideia é ter uma condição e se ela for verdadeira retornar um valor se não retornar outro, sua estrutura é bem simples 

- (condição) ? 'Valor retornado para verdadeiro' : 'Valor retornado para falso';

----------------------------------------------------------------------------------------------------------

VALORES FALSY

- 0 -> se usado em uma condição seu valor booleano é falso 
- '' ou "" ou `` -> se usado em uma condição seu valor booleano é falso
- null -> se usado em uma condição seu valor booleano é falso
- undefined -> se usado em uma condição seu valor booleano é falso
- NaN -> se usado em uma condição seu valor booleano é falso

----------------------------------------------------------------------------------------------------------

ATRIBUIÇÃO VIA DESESTRUTURAÇÃO DE ARRAYS

- pode fazer uma desestruturação de um array para criar variáveis com os valores desse array

const array = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000];
const [peimeiroNumero, segundoNumero] = array; -> primeiroNumero terá o valor 1000 e segundoNumero terá valor 2000

const [primeiroNumero, segundoNumero, ...resto] = array; -> primeiroNumero terá 1000, segundoNumero terá 2000 e resto terá todos os outros valores que sobraram

const [um, , tres, , cinco] = array; -> tem a mesma ideia porém, vai pulando alguns valores

- ... -> tem dois nomes, pode ser chamado de rest operator e spread operator, ou seja, tem duas funcionalidades, o rest é para que ele pegue o resto e o spread é para que ele espalhe os valores que sobraram

----------------------------------------------------------------------------------------------------------

ATRIBUIÇÃO VIA DESESTRUTURAÇÃO DE OBJETOS 

- segue a mesma ideia da desestruturação de arrays, porém, nesse caso precisa-se especificar o campo que quer desestruturar

const pessoa = {
    nome: 'Luiz',
    sobrenome: 'Miranda',
    idade: 30,
    endereco: {
        rua: 'Acácias',
        numero: 235
    }
};

const { nome, sobrenome } = pessoa; -> variável nome tem o valor de 'Luiz' agora e variável sobrenome tem o valor de 'Miranda'

// para criar uma nova variável que irá receber o valor que tem em algum campo basta colocar nomeCampo: nomeVariável
const { nome: teste } = pessoa; -> variável teste tem o valor de 'Luiz' agora

// para pegar a rua por exemplo vai seguir a mesma ideia, porém, é necessário pegar o campo endereco e especificar depois os outros campos
const { endereco: { rua, numero } } = pessoa; -> agora a variável rua tem o valor 'Acácias' e a variável numero tem o valor 235

// é possível colocar um valor padrão também como se fosse a função
const { endereco: { rua = 'Hortências', numero } } = pessoa; -> agora a variável rua tem o valor 'Acácias', porém, se rua estivesse vazia ela receberia o valor padrão de 'Hortências' e a variável numero tem o valor 235

- é possível também usar o operador de rest (...) para pegar os valores que sobrarem também 

----------------------------------------------------------------------------------------------------------

SHORT-CIRCUIT

- no JS, quando há uma expressão lógica ele entende os operadores e vai procurar apenas o valor que condizer com a operação, por exemplo, se tenho uma expressão que utiliza o '&&', ele vai procurar dentro da expressão se houver algo false ele retorna esse valor false -> console.log('João' && '' && 1) => o retorno é a string vazia '', pois, esse valor é considerado falso pelo JS, se não, se todos os valores forem verdadeiros é retornado o último valor

- o mesmo vale para o operador OR || -> esse operador fará a mesma coisa, porém, a sua diferença é que ele retoirna o primeiro valor true que encontrar, se todos os valores forem falsos o que será retornado é o último valor 

----------------------------------------------------------------------------------------------------------

FOR IN

- usado para percorrer cada índice de elemento de um vetor (array) ou chaves de um objeto 

const frutas = ['Pera', 'Maçã', 'Uva'];
for(let i in frutas) {
    console.log(i);
}

- nesse caso ele irá mostrar os índices do array, ou seja, irá printar os números dos índices e não os valores, para printar os valores bastaria colocar console.log(frutas[i]);

const pessoa = {
    nome: 'Luiz',
    sobrenome: 'Miranda',
    idade: 30
};
for(let chave in pessoa) {
    console.log(chave, pessoa[chave]); -> irá exibir o nome da chave e o valor dessa chave para esse objeto, nesse caso 'nome Luiz' primeiro;
}

- FOR IN COM QUALQUER TIPO DE DADO QUE TENHA ÍNDICE (ARRAYS, STRINGS OU OBJETOS)

----------------------------------------------------------------------------------------------------------

FOR OF 

- mesma coisa do FOR IN, a única diferença é que com o IN é retornado o índice de um array e a chave de um objeto, com o OF é retornado o valor do array ou da string

const frutas = ['Pera', 'Maçã', 'Uva'];
for(let i of frutas) {
    console.log(i);
}

- nesse caso ele irá mostrar os valores do array, ou seja, irá printar o nome das frutas

- FOR OF APENAS COM ITERÁVEIS (ARRAYS OU STRINGS)

----------------------------------------------------------------------------------------------------------

FOREACH

- usado como uma função de arrays, ou seja, é chamado a partir de um array, não tem como chamá-lo sozinho

array.forEach(function(el, in, array) {
    // código
});

- os parâmetros que podem ser passados para essa função são o elemento, índice e o próprio array, sendo passados é possível utilizá-los dentro da função 

----------------------------------------------------------------------------------------------------------

TRY, CATCH, THROW E FINALLY

- try -> tenta executar o bloco de código e para se acha algum erro, executa tudo e para no erro, não executando dele para baixo

- catch -> é executado o bloco de código do catch quando é gerado algum erro no try, o catch recebe como parâmtero o erro que foi gerado 

- throw -> usado para 'jogar' o erro, esse throw geralmente é sucedido de uma função contrutora que irá mostrar ao usuário onde ocorreu o erro e qual foi o erro, se o throw estiver dentro de uma função a função é parada de executar imediatamente

throw new ReferenceError('x e y não são números'); -> esse é um exemplo de função contrutora, o que é passado dentro dos parênteses vai ser enviado ao catch para mostrar ao usuário

- finally -> sempre é executado independentemente se gerou erro ou não

----------------------------------------------------------------------------------------------------------

OBSERVAÇÕES 

- JS aceita que você faça uma inversão dos valores de variáveis mais facilmente utilizando colchetes, por exemplo, varA, varB, varC quero inverter os valores sem criar uma nova variável, para isso basta usar os colchetes [varA, varB, varC] = [varB, varC, varA] -> agora o varA recebeu o valor antigo de varB, o varB recebeu o valor antigo de varC e o varC recebeu o valor antigo de varA

- usar a barra invertida indica o escape de algum caractere que vem depois ou ele vai fazer alguma formatação como é o caso de \t que é um tab dentro do texto, então para colocar o \ dentro do texto você usa duas \\ dessa forma uma contra barra será printada dentro da sua string

- no JS quando se soma números de ponto flutuante ele fica impreciso, vai dar um número quebrado, EX: 0.7 + 0.1 = 0.799999... para consertar isso, usa-se a função Numbar(soma.toFixed(2)), isso resultará em o número sendo deixado com apenas duas casas decimais e quando ele for inteiro ele será convertido para inteiro e quando não for inteiro ele será convertido para ponto flutuante

- ficar atento, números divididos por zero em JS não dão erro, eles são retornados como true ainda, ou seja, é uma conta válida dentro do JS, retornará um tipo de dado chamado Infinity

- JS faz hoisting, ou seja, qualquer variável criada com var ou qualquer function é elevada ao topo do arquivo, ou seja, eles sempre ficam a cima de todo o código, por isso que é indiferente você criar a função e depois chamá-la ou chamá-la e depois criar a função, pois, para o JS ele sempre coloca na ordem certa para essa chamada 